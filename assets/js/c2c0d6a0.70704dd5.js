"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([["20973"],{99668:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,contentTitle:()=>s,default:()=>h,assets:()=>c,toc:()=>d,frontMatter:()=>r});var a=JSON.parse('{"id":"custom-navigators","title":"Custom navigators","description":"Navigators allow you to define your application\'s navigation structure. Navigators also render common elements such as headers and tab bars which you can configure.","source":"@site/versioned_docs/version-7.x/custom-navigators.md","sourceDirName":".","slug":"/custom-navigators","permalink":"/docs/custom-navigators","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/custom-navigators.md","tags":[],"version":"7.x","frontMatter":{"id":"custom-navigators","title":"Custom navigators","sidebar_label":"Custom navigators"},"sidebar":"docs","previous":{"title":"Custom routers","permalink":"/docs/custom-routers"},"next":{"title":"Migration Guides","permalink":"/docs/migration-guides"}}'),i=t("85893"),o=t("50065");let r={id:"custom-navigators",title:"Custom navigators",sidebar_label:"Custom navigators"},s=void 0,c={},d=[{value:"Built-in Navigators",id:"built-in-navigators",level:2},{value:"API for building custom navigators",id:"api-for-building-custom-navigators",level:2},{value:"<code>useNavigationBuilder</code>",id:"usenavigationbuilder",level:3},{value:"<code>createNavigatorFactory</code>",id:"createnavigatorfactory",level:3},{value:"Type-checking navigators",id:"type-checking-navigators",level:2},{value:"Extending Navigators",id:"extending-navigators",level:2}];function l(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Navigators allow you to define your application's navigation structure. Navigators also render common elements such as headers and tab bars which you can configure."}),"\n",(0,i.jsx)(n.p,{children:"Under the hood, navigators are plain React components."}),"\n",(0,i.jsx)(n.h2,{id:"built-in-navigators",children:"Built-in Navigators"}),"\n",(0,i.jsx)(n.p,{children:"We include some commonly needed navigators such as:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/stack-navigator",children:(0,i.jsx)(n.code,{children:"createStackNavigator"})})," - Renders one screen at a time and provides transitions between screens. When a new screen is opened it is placed on top of the stack."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/drawer-navigator",children:(0,i.jsx)(n.code,{children:"createDrawerNavigator"})})," - Provides a drawer that slides in from the left of the screen by default."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/bottom-tab-navigator",children:(0,i.jsx)(n.code,{children:"createBottomTabNavigator"})})," - Renders a tab bar that lets the user switch between several screens."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/material-top-tab-navigator",children:(0,i.jsx)(n.code,{children:"createMaterialTopTabNavigator"})})," - Renders tab view which lets the user switch between several screens using swipe gesture or the tab bar."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"api-for-building-custom-navigators",children:"API for building custom navigators"}),"\n",(0,i.jsxs)(n.p,{children:["A navigator bundles a router and a view which takes the ",(0,i.jsx)(n.a,{href:"/docs/navigation-state",children:"navigation state"})," and decides how to render it. We export a ",(0,i.jsx)(n.code,{children:"useNavigationBuilder"})," hook to build custom navigators that integrate with rest of React Navigation."]}),"\n",(0,i.jsx)(n.h3,{id:"usenavigationbuilder",children:(0,i.jsx)(n.code,{children:"useNavigationBuilder"})}),"\n",(0,i.jsx)(n.p,{children:"This hook allows a component to hook into React Navigation. It accepts the following arguments:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"createRouter"})," - A factory method which returns a router object (e.g. ",(0,i.jsx)(n.code,{children:"StackRouter"}),", ",(0,i.jsx)(n.code,{children:"TabRouter"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"options"})," - Options for the hook and the router. The navigator should forward its props here so that user can provide props to configure the navigator. By default, the following options are accepted:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"children"})," (required) - The ",(0,i.jsx)(n.code,{children:"children"})," prop should contain route configurations as ",(0,i.jsx)(n.code,{children:"Screen"})," components."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"screenOptions"})," - The ",(0,i.jsx)(n.code,{children:"screenOptions"})," prop should contain default options for all of the screens."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"initialRouteName"})," - The ",(0,i.jsx)(n.code,{children:"initialRouteName"})," prop determines the screen to focus on initial render. This prop is forwarded to the router."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If any other options are passed here, they'll be forwarded to the router."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The hook returns an object with following properties:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"state"})," - The ",(0,i.jsx)(n.a,{href:"/docs/navigation-state",children:"navigation state"})," for the navigator. The component can take this state and decide how to render it."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"navigation"})," - The navigation object containing various helper methods for the navigator to manipulate the ",(0,i.jsx)(n.a,{href:"/docs/navigation-state",children:"navigation state"}),". This isn't the same as the navigation object for the screen and includes some helpers such as ",(0,i.jsx)(n.code,{children:"emit"})," to emit events to the screens."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"descriptors"})," - This is an object containing descriptors for each route with the route keys as its properties. The descriptor for a route can be accessed by ",(0,i.jsx)(n.code,{children:"descriptors[route.key]"}),". Each descriptor contains the following properties:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"navigation"})," - The navigation object for the screen. You don't need to pass this to the screen manually. But it's useful if we're rendering components outside the screen that need to receive ",(0,i.jsx)(n.code,{children:"navigation"})," prop as well, such as a header component."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"options"})," - A getter which returns the options such as ",(0,i.jsx)(n.code,{children:"title"})," for the screen if they are specified."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"render"})," - A function which can be used to render the actual screen. Calling ",(0,i.jsx)(n.code,{children:"descriptors[route.key].render()"})," will return a React element containing the screen content. It's important to use this method to render a screen, otherwise any child navigators won't be connected to the navigation tree properly."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import * as React from 'react';\nimport { Text, Pressable, View } from 'react-native';\nimport {\n  NavigationHelpersContext,\n  useNavigationBuilder,\n  TabRouter,\n  TabActions,\n} from '@react-navigation/native';\n\nfunction TabNavigator({ tabBarStyle, contentStyle, ...rest }) {\n  const { state, navigation, descriptors, NavigationContent } =\n    useNavigationBuilder(TabRouter, rest);\n\n  return (\n    <NavigationContent>\n      <View style={[{ flexDirection: 'row' }, tabBarStyle]}>\n        {state.routes.map((route, index) => (\n          <Pressable\n            key={route.key}\n            onPress={() => {\n              const isFocused = state.index === index;\n              const event = navigation.emit({\n                type: 'tabPress',\n                target: route.key,\n                canPreventDefault: true,\n              });\n\n              if (!isFocused && !event.defaultPrevented) {\n                navigation.dispatch({\n                  ...TabActions.jumpTo(route.name, route.params),\n                  target: state.key,\n                });\n              }\n            }}\n            style={{ flex: 1 }}\n          >\n            <Text>{descriptors[route.key].options.title ?? route.name}</Text>\n          </Pressable>\n        ))}\n      </View>\n      <View style={[{ flex: 1 }, contentStyle]}>\n        {state.routes.map((route, i) => {\n          return (\n            <View\n              key={route.key}\n              style={[\n                StyleSheet.absoluteFill,\n                { display: i === state.index ? 'flex' : 'none' },\n              ]}\n            >\n              {descriptors[route.key].render()}\n            </View>\n          );\n        })}\n      </View>\n    </NavigationContent>\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"navigation"})," object for navigators also has an ",(0,i.jsx)(n.code,{children:"emit"})," method to emit custom events to the child screens. The usage looks like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"navigation.emit({\n  type: 'transitionStart',\n  data: { blurring: false },\n  target: route.key,\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"data"})," is available under the ",(0,i.jsx)(n.code,{children:"data"})," property in the ",(0,i.jsx)(n.code,{children:"event"})," object, i.e. ",(0,i.jsx)(n.code,{children:"event.data"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"target"})," property determines the screen that will receive the event. If the ",(0,i.jsx)(n.code,{children:"target"})," property is omitted, the event is dispatched to all screens in the navigator."]}),"\n",(0,i.jsx)(n.h3,{id:"createnavigatorfactory",children:(0,i.jsx)(n.code,{children:"createNavigatorFactory"})}),"\n",(0,i.jsxs)(n.p,{children:["This ",(0,i.jsx)(n.code,{children:"createNavigatorFactory"})," function is used to create a function that will ",(0,i.jsx)(n.code,{children:"Navigator"})," and ",(0,i.jsx)(n.code,{children:"Screen"})," pair. Custom navigators need to wrap the navigator component in ",(0,i.jsx)(n.code,{children:"createNavigatorFactory"})," before exporting."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import {\n  useNavigationBuilder,\n  createNavigatorFactory,\n} from '@react-navigation/native';\n\n// ...\n\nexport function createMyNavigator(config) {\n  return createNavigatorFactory(TabNavigator)(config);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then it can be used like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'import { createMyNavigator } from \'./myNavigator\';\n\nconst My = createMyNavigator();\n\nfunction App() {\n  return (\n    <My.Navigator>\n      <My.Screen name="Home" component={HomeScreen} />\n      <My.Screen name="Feed" component={FeedScreen} />\n    </My.Navigator>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"type-checking-navigators",children:"Type-checking navigators"}),"\n",(0,i.jsx)(n.p,{children:"To type-check navigators, we need to provide 3 types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Type of the props accepted by the view"}),"\n",(0,i.jsx)(n.li,{children:"Type of supported screen options"}),"\n",(0,i.jsx)(n.li,{children:"A map of event types emitted by the navigator"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For example, to type-check our custom tab navigator, we can do something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import * as React from 'react';\nimport {\n  View,\n  Text,\n  Pressable,\n  type StyleProp,\n  type ViewStyle,\n  StyleSheet,\n} from 'react-native';\nimport {\n  createNavigatorFactory,\n  CommonActions,\n  type DefaultNavigatorOptions,\n  type NavigatorTypeBagBase,\n  type ParamListBase,\n  type StaticConfig,\n  type TabActionHelpers,\n  type TabNavigationState,\n  TabRouter,\n  type TabRouterOptions,\n  type TypedNavigator,\n  useNavigationBuilder,\n} from '@react-navigation/native';\n\n// Additional props accepted by the view\ntype TabNavigationConfig = {\n  tabBarStyle: StyleProp<ViewStyle>;\n  contentStyle: StyleProp<ViewStyle>;\n};\n\n// Supported screen options\ntype TabNavigationOptions = {\n  title?: string;\n};\n\n// Map of event name and the type of data (in event.data)\n// canPreventDefault: true adds the defaultPrevented property to the\n// emitted events.\ntype TabNavigationEventMap = {\n  tabPress: {\n    data: { isAlreadyFocused: boolean };\n    canPreventDefault: true;\n  };\n};\n\n// The props accepted by the component is a combination of 3 things\ntype Props = DefaultNavigatorOptions<\n  ParamListBase,\n  TabNavigationState<ParamListBase>,\n  TabNavigationOptions,\n  TabNavigationEventMap\n> &\n  TabRouterOptions &\n  TabNavigationConfig;\n\nfunction TabNavigator({ tabBarStyle, contentStyle, ...rest }: Props) {\n  const { state, navigation, descriptors, NavigationContent } =\n    useNavigationBuilder<\n      TabNavigationState<ParamListBase>,\n      TabRouterOptions,\n      TabActionHelpers<ParamListBase>,\n      TabNavigationOptions,\n      TabNavigationEventMap\n    >(TabRouter, rest);\n\n  return (\n    <NavigationContent>\n      <View style={[{ flexDirection: 'row' }, tabBarStyle]}>\n        {state.routes.map((route, index) => (\n          <Pressable\n            key={route.key}\n            onPress={() => {\n              const isFocused = state.index === index;\n              const event = navigation.emit({\n                type: 'tabPress',\n                target: route.key,\n                canPreventDefault: true,\n                data: {\n                  isAlreadyFocused: isFocused,\n                },\n              });\n\n              if (!isFocused && !event.defaultPrevented) {\n                navigation.dispatch({\n                  ...CommonActions.navigate(route),\n                  target: state.key,\n                });\n              }\n            }}\n            style={{ flex: 1 }}\n          >\n            <Text>{descriptors[route.key].options.title || route.name}</Text>\n          </Pressable>\n        ))}\n      </View>\n      <View style={[{ flex: 1 }, contentStyle]}>\n        {state.routes.map((route, i) => {\n          return (\n            <View\n              key={route.key}\n              style={[\n                StyleSheet.absoluteFill,\n                { display: i === state.index ? 'flex' : 'none' },\n              ]}\n            >\n              {descriptors[route.key].render()}\n            </View>\n          );\n        })}\n      </View>\n    </NavigationContent>\n  );\n}\n\n// The factory function with generic types for type-inference\nexport function createMyNavigator<\n  const ParamList extends ParamListBase,\n  const NavigatorID extends string | undefined = undefined,\n  const TypeBag extends NavigatorTypeBagBase = {\n    ParamList: ParamList;\n    NavigatorID: NavigatorID;\n    State: TabNavigationState<ParamList>;\n    ScreenOptions: TabNavigationOptions;\n    EventMap: TabNavigationEventMap;\n    NavigationList: {\n      [RouteName in keyof ParamList]: TabNavigationProp<\n        ParamList,\n        RouteName,\n        NavigatorID\n      >;\n    };\n    Navigator: typeof TabNavigator;\n  },\n  const Config extends StaticConfig<TypeBag> = StaticConfig<TypeBag>,\n>(config?: Config): TypedNavigator<TypeBag, Config> {\n  return createNavigatorFactory(TabNavigator)(config);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"extending-navigators",children:"Extending Navigators"}),"\n",(0,i.jsx)(n.p,{children:"All of the built-in navigators export their views, which we can reuse and build additional functionality on top of them. For example, if we want to re-build the bottom tab navigator, we need the following code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import * as React from 'react';\nimport {\n  useNavigationBuilder,\n  createNavigatorFactory,\n  TabRouter,\n} from '@react-navigation/native';\nimport { BottomTabView } from '@react-navigation/bottom-tabs';\n\nfunction BottomTabNavigator({\n  id,\n  initialRouteName,\n  children,\n  layout,\n  screenListeners,\n  screenOptions,\n  screenLayout,\n  backBehavior,\n  ...rest\n}) {\n  const { state, descriptors, navigation, NavigationContent } =\n    useNavigationBuilder(TabRouter, {\n      id,\n      initialRouteName,\n      children,\n      layout,\n      screenListeners,\n      screenOptions,\n      screenLayout,\n      backBehavior,\n    });\n\n  return (\n    <NavigationContent>\n      <BottomTabView\n        {...rest}\n        state={state}\n        navigation={navigation}\n        descriptors={descriptors}\n      />\n    </NavigationContent>\n  );\n}\n\nexport function createMyNavigator(config) {\n  return createNavigatorFactory(TabNavigator)(config);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, we can customize it to add additional functionality or change the behavior. For example, use a ",(0,i.jsx)(n.a,{href:"/docs/custom-routers",children:"custom router"})," instead of the default ",(0,i.jsx)(n.code,{children:"TabRouter"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import MyRouter from './MyRouter';\n\n// ...\n\nconst { state, descriptors, navigation, NavigationContent } =\n  useNavigationBuilder(MyRouter, {\n    id,\n    initialRouteName,\n    children,\n    layout,\n    screenListeners,\n    screenOptions,\n    screenLayout,\n    backBehavior,\n  });\n\n// ...\n"})})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},50065:function(e,n,t){t.d(n,{Z:function(){return s},a:function(){return r}});var a=t(67294);let i={},o=a.createContext(i);function r(e){let n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);